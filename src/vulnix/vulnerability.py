from persistent import Persistent
from .utils import compare_versions


class Vulnerability(Persistent):

    cve_id = None
    nodes = None
    cvss2 = None
    cvss3 = None

    def __init__(self, cve_id, nodes=None, cvss2=None, cvss3=None):
        self.cve_id = cve_id
        self.nodes = nodes or []
        self.cvss2 = cvss2
        self.cvss3 = cvss3

    @classmethod
    def parse(cls, item):
        res = cls(item['cve']['CVE_data_meta']['ID'])
        if 'configurations' in item:
            res.nodes = Node.parse(item['configurations'].get('nodes', {}))
        return res

    def __str__(self):
        return self.cve_id

    def __repr__(self):
        return '<Vulnerability {}>'.format(self.cve_id)

    def __eq__(self, other):
        return self.cve_id == other.cve_id

    def __lt__(self, other):
        return self.cve_id < other.cve_id

    def __gt__(self, other):
        return self.cve_id > other.cve_id

    def __hash__(self):
        return hash(self.cve_id)

    def match(self, _pname, pvers):
        for n in self.nodes:
            if all(version_match(pvers, v) for v in n.versions):
                return True
        return False


class Node(Persistent):

    vendor = None
    product = None
    versions = None

    def __init__(self, vendor, product, versions=None):
        self.vendor = vendor
        self.product = product
        self.versions = versions or []

    @classmethod
    def parse(cls, nodes):
        res = []
        for node in nodes:
            res += cls.parse_matches(node.get('cpe_match', []))
            res += cls.parse(node.get('children', []))
        return res

    @classmethod
    def parse_matches(cls, cpe_match):
        nodes = []
        for expr in cpe_match:
            if expr.get('vulnerable') is not True:
                continue
            (cpe, cpevers, typ, vendor, product, vers, rev, _) = \
                expr['cpe23Uri'].split(':', 7)
            if cpe != 'cpe' or cpevers != '2.3' or typ != 'a':
                continue
            e = cls(vendor, product)
            v = e.versions
            if 'versionStartIncluding' in expr:
                v.append('>=' + expr['versionStartIncluding'])
            if 'versionStartExcluding' in expr:
                v.append('>' + expr['versionStartExcluding'])
            if 'versionEndIncluding' in expr:
                v.append('<=' + expr['versionEndIncluding'])
            if 'versionEndExcluding' in expr:
                v.append('<' + expr['versionEndExcluding'])
            if vers and vers != '*' and vers != '-':
                if rev and rev != '*' and rev != '-':
                    vers = vers + '-' + rev
                v.append('=' + vers)
            # no point adding an expr without any version match
            if v:
                nodes.append(e)
        return nodes

    def __eq__(self, other):
        return (self.vendor == other.vendor and
                self.product == other.product and
                self.versions == other.versions)

    def __repr__(self):
        return '<Node {}:{}, {}>'.format(
            self.vendor, self.product, self.versions)


def version_match(pvers, spec):
    """Returns True if package version `pvers` complies with `spec`."""
    if spec[0] == '=':
        return compare_versions(pvers, spec[1:]) == 0
    elif spec[0] == '>':
        if spec[1] == '=':
            return compare_versions(pvers, spec[2:]) in (0, 1)
        return compare_versions(pvers, spec[1:]) == 1
    elif spec[0] == '<':
        if spec[1] == '=':
            return compare_versions(pvers, spec[2:]) in (-1, 0)
        return compare_versions(pvers, spec[1:]) == -1
    raise ValueError('Invalid version spec', spec)
